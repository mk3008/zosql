import{c as t,R as e,T as i,h as s,p as a,a as l,x as h,U as o}from"./pglite-IPxksoss.js";import"./monaco-editor-BxywP6eC.js";l();var r,n,c,d,p,w,f,y,u,m,g,S,k,O,b,N,E,F,M,P,D=16384,I=32768,_=class extends t{constructor(t,{initialPoolSize:i=1e3,maintainedPoolSize:s=100,debug:a=!1}={}){super(t,{debug:a}),e(this,S),e(this,r),e(this,n),e(this,c),e(this,d),e(this,p),e(this,w,new Map),e(this,f,new Map),e(this,y,0),e(this,u,new Map),e(this,m,new Map),this.lastCheckpoint=0,this.checkpointInterval=6e4,this.poolCounter=0,e(this,g,new Set),this.initialPoolSize=i,this.maintainedPoolSize=s}async init(t,e){return await i(this,S,k).call(this),super.init(t,e)}async syncToFs(t=!1){await this.maybeCheckpointState(),await this.maintainPool(),t||this.flush()}async closeFs(){for(let t of s(this,f).values())t.close();s(this,p).flush(),s(this,p).close(),this.pg.Module.FS.quit()}async maintainPool(t){let e=(t=t||this.maintainedPoolSize)-this.state.pool.length,a=[];for(let l=0;l<e;l++)a.push(new Promise(async t=>{++this.poolCounter;let e=`${(Date.now()-1704063600).toString(16).padStart(8,"0")}-${this.poolCounter.toString(16).padStart(8,"0")}`,a=await s(this,c).getFileHandle(e,{create:!0}),l=await a.createSyncAccessHandle();s(this,w).set(e,a),s(this,f).set(e,l),i(this,S,b).call(this,{opp:"createPoolFile",args:[e]}),this.state.pool.push(e),t()}));for(let l=0;l>e;l--)a.push(new Promise(async t=>{var e;let a=this.state.pool.pop();i(this,S,b).call(this,{opp:"deletePoolFile",args:[a]});let l=s(this,w).get(a);null==(e=s(this,f).get(a))||e.close(),await s(this,c).removeEntry(l.name),s(this,w).delete(a),s(this,f).delete(a),t()}));await Promise.all(a)}_createPoolFileState(t){this.state.pool.push(t)}_deletePoolFileState(t){let e=this.state.pool.indexOf(t);e>-1&&this.state.pool.splice(e,1)}async maybeCheckpointState(){Date.now()-this.lastCheckpoint>this.checkpointInterval&&await this.checkpointState()}async checkpointState(){let t=(new TextEncoder).encode(JSON.stringify(this.state));s(this,p).truncate(0),s(this,p).write(t,{at:0}),s(this,p).flush(),this.lastCheckpoint=Date.now()}flush(){for(let t of s(this,g))try{t.flush()}catch{}s(this,g).clear()}chmod(t,e){i(this,S,O).call(this,{opp:"chmod",args:[t,e]},()=>{this._chmodState(t,e)})}_chmodState(t,e){i(this,S,E).call(this,t).mode=e}close(t){let e=i(this,S,F).call(this,t);s(this,u).delete(t),s(this,m).delete(e)}fstat(t){let e=i(this,S,F).call(this,t);return this.lstat(e)}lstat(t){let e=i(this,S,E).call(this,t),a="file"===e.type?s(this,f).get(e.backingFilename).getSize():0;return{dev:0,ino:0,mode:e.mode,nlink:1,uid:0,gid:0,rdev:0,size:a,blksize:4096,blocks:Math.ceil(a/4096),atime:e.lastModified,mtime:e.lastModified,ctime:e.lastModified}}mkdir(t,e){i(this,S,O).call(this,{opp:"mkdir",args:[t,e]},()=>{this._mkdirState(t,e)})}_mkdirState(t,e){let s=i(this,S,N).call(this,t),a=s.pop(),l=[],h=this.state.root;for(let i of s){if(l.push(t),!Object.prototype.hasOwnProperty.call(h.children,i)){if(!(null==e?void 0:e.recursive))throw new j("ENOENT","No such file or directory");this.mkdir(l.join("/"))}if("directory"!==h.children[i].type)throw new j("ENOTDIR","Not a directory");h=h.children[i]}if(Object.prototype.hasOwnProperty.call(h.children,a))throw new j("EEXIST","File exists");let o={type:"directory",lastModified:Date.now(),mode:(null==e?void 0:e.mode)||D,children:{}};h.children[a]=o}open(t,e,a){if("file"!==i(this,S,E).call(this,t).type)throw new j("EISDIR","Is a directory");let l=i(this,S,M).call(this);return s(this,u).set(l,t),s(this,m).set(t,l),l}readdir(t){let e=i(this,S,E).call(this,t);if("directory"!==e.type)throw new j("ENOTDIR","Not a directory");return Object.keys(e.children)}read(t,e,a,l,h){let o=i(this,S,F).call(this,t),r=i(this,S,E).call(this,o);if("file"!==r.type)throw new j("EISDIR","Is a directory");return s(this,f).get(r.backingFilename).read(new Uint8Array(e.buffer,a,l),{at:h})}rename(t,e){i(this,S,O).call(this,{opp:"rename",args:[t,e]},()=>{this._renameState(t,e,!0)})}_renameState(t,e,a=!1){let l=i(this,S,N).call(this,t),h=l.pop(),o=i(this,S,E).call(this,l.join("/"));if(!Object.prototype.hasOwnProperty.call(o.children,h))throw new j("ENOENT","No such file or directory");let r=i(this,S,N).call(this,e),n=r.pop(),c=i(this,S,E).call(this,r.join("/"));if(a&&Object.prototype.hasOwnProperty.call(c.children,n)){let t=c.children[n];s(this,f).get(t.backingFilename).truncate(0),this.state.pool.push(t.backingFilename)}c.children[n]=o.children[h],delete o.children[h]}rmdir(t){i(this,S,O).call(this,{opp:"rmdir",args:[t]},()=>{this._rmdirState(t)})}_rmdirState(t){let e=i(this,S,N).call(this,t),s=e.pop(),a=i(this,S,E).call(this,e.join("/"));if(!Object.prototype.hasOwnProperty.call(a.children,s))throw new j("ENOENT","No such file or directory");let l=a.children[s];if("directory"!==l.type)throw new j("ENOTDIR","Not a directory");if(Object.keys(l.children).length>0)throw new j("ENOTEMPTY","Directory not empty");delete a.children[s]}truncate(t,e=0){let a=i(this,S,E).call(this,t);if("file"!==a.type)throw new j("EISDIR","Is a directory");let l=s(this,f).get(a.backingFilename);if(!l)throw new j("ENOENT","No such file or directory");l.truncate(e),s(this,g).add(l)}unlink(t){i(this,S,O).call(this,{opp:"unlink",args:[t]},()=>{this._unlinkState(t,!0)})}_unlinkState(t,e=!1){let a=i(this,S,N).call(this,t),l=a.pop(),h=i(this,S,E).call(this,a.join("/"));if(!Object.prototype.hasOwnProperty.call(h.children,l))throw new j("ENOENT","No such file or directory");let o=h.children[l];if("file"!==o.type)throw new j("EISDIR","Is a directory");if(delete h.children[l],e){let e=s(this,f).get(o.backingFilename);null==e||e.truncate(0),s(this,g).add(e),s(this,m).has(t)&&(s(this,u).delete(s(this,m).get(t)),s(this,m).delete(t))}this.state.pool.push(o.backingFilename)}utimes(t,e,s){i(this,S,O).call(this,{opp:"utimes",args:[t,e,s]},()=>{this._utimesState(t,e,s)})}_utimesState(t,e,s){i(this,S,E).call(this,t).lastModified=s}writeFile(t,e,a){let l=i(this,S,N).call(this,t),h=l.pop(),o=i(this,S,E).call(this,l.join("/"));if(Object.prototype.hasOwnProperty.call(o.children,h)){let e=o.children[h];e.lastModified=Date.now(),i(this,S,b).call(this,{opp:"setLastModified",args:[t,e.lastModified]})}else{if(0===this.state.pool.length)throw new Error("No more file handles available in the pool");let e={type:"file",lastModified:Date.now(),mode:(null==a?void 0:a.mode)||I,backingFilename:this.state.pool.pop()};o.children[h]=e,i(this,S,b).call(this,{opp:"createFileNode",args:[t,e]})}let r=o.children[h],n=s(this,f).get(r.backingFilename);e.length>0&&(n.write("string"==typeof e?(new TextEncoder).encode(e):new Uint8Array(e),{at:0}),t.startsWith("/pg_wal")&&s(this,g).add(n))}_createFileNodeState(t,e){let s=i(this,S,N).call(this,t),a=s.pop();i(this,S,E).call(this,s.join("/")).children[a]=e;let l=this.state.pool.indexOf(e.backingFilename);return l>-1&&this.state.pool.splice(l,1),e}_setLastModifiedState(t,e){i(this,S,E).call(this,t).lastModified=e}write(t,e,a,l,h){let o=i(this,S,F).call(this,t),r=i(this,S,E).call(this,o);if("file"!==r.type)throw new j("EISDIR","Is a directory");let n=s(this,f).get(r.backingFilename);if(!n)throw new j("EBADF","Bad file descriptor");let c=n.write(new Uint8Array(e,a,l),{at:h});return o.startsWith("/pg_wal")&&s(this,g).add(n),c}};r=new WeakMap,n=new WeakMap,c=new WeakMap,d=new WeakMap,p=new WeakMap,w=new WeakMap,f=new WeakMap,y=new WeakMap,u=new WeakMap,m=new WeakMap,g=new WeakMap,S=new WeakSet,k=async function(){h(this,r,await navigator.storage.getDirectory()),h(this,n,await i(this,S,P).call(this,this.dataDir,{create:!0})),h(this,c,await i(this,S,P).call(this,"data",{from:s(this,n),create:!0})),h(this,d,await s(this,n).getFileHandle("state.txt",{create:!0})),h(this,p,await s(this,d).createSyncAccessHandle());let t=new ArrayBuffer(s(this,p).getSize());s(this,p).read(t,{at:0});let e,a=(new TextDecoder).decode(t).split("\n"),l=!1;try{e=JSON.parse(a[0])}catch{e={root:{type:"directory",lastModified:Date.now(),mode:D,children:{}},pool:[]},s(this,p).truncate(0),s(this,p).write((new TextEncoder).encode(JSON.stringify(e)),{at:0}),l=!0}this.state=e;let o=a.slice(1).filter(Boolean).map(t=>JSON.parse(t));for(let i of o){let t=`_${i.opp}State`;if("function"==typeof this[t])try{this[t].bind(this)(...i.args)}catch(g){}}let y=[],u=async t=>{if("file"===t.type)try{let e=await s(this,c).getFileHandle(t.backingFilename),i=await e.createSyncAccessHandle();s(this,w).set(t.backingFilename,e),s(this,f).set(t.backingFilename,i)}catch(e){}else for(let i of Object.values(t.children))y.push(u(i))};await u(this.state.root);let m=[];for(let i of this.state.pool)m.push(new Promise(async t=>{s(this,w).has(i);let e=await s(this,c).getFileHandle(i),a=await e.createSyncAccessHandle();s(this,w).set(i,e),s(this,f).set(i,a),t()}));await Promise.all([...y,...m]),await this.maintainPool(l?this.initialPoolSize:this.maintainedPoolSize)},O=function(t,e){let a=i(this,S,b).call(this,t);try{e()}catch(l){throw s(this,p).truncate(a),l}},b=function(t){let e=JSON.stringify(t),i=(new TextEncoder).encode(`\n${e}`),a=s(this,p).getSize();return s(this,p).write(i,{at:a}),s(this,g).add(s(this,p)),a},N=function(t){return t.split("/").filter(Boolean)},E=function(t,e){let s=i(this,S,N).call(this,t),a=e||this.state.root;for(let i of s){if("directory"!==a.type)throw new j("ENOTDIR","Not a directory");if(!Object.prototype.hasOwnProperty.call(a.children,i))throw new j("ENOENT","No such file or directory");a=a.children[i]}return a},F=function(t){let e=s(this,u).get(t);if(!e)throw new j("EBADF","Bad file descriptor");return e},M=function(){let t=++o(this,y)._;for(;s(this,u).has(t);)o(this,y)._++;return t},P=async function(t,e){let a=i(this,S,N).call(this,t),l=(null==e?void 0:e.from)||s(this,r);for(let i of a)l=await l.getDirectoryHandle(i,{create:null==e?void 0:e.create});return l};var j=class extends Error{constructor(t,e){super(e),"number"==typeof t?this.code=t:"string"==typeof t&&(this.code=a[t])}};export{_ as OpfsAhpFS};
